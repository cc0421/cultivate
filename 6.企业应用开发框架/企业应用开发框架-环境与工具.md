

## 附录1：开发环境配置

### 1.  JDK安装

#### 1.1 下载JDK

JDK1.8下载地址：https://www.oracle.com/cn/java/technologies/javase/javase-jdk8-downloads.html

选择Windows x64（32位系统选择x86）

![image-20201008165419542](img/image-20201008165419542.png)

![image-20201008165510816](img/image-20201008165510816.png)

选中同意，开始下载

![image-20201008165628383](img/image-20201008165628383.png)

#### 1.2 安装JDK

下载好后双击安装

![image-20201008170746249](img/image-20201008170746249.png)

点击下一步

<img src="img/image-20201008170909961.png" alt="image-20201008170909961" style="zoom: 80%;" />

更改路径

![image-20201008175445238](img/image-20201008175445238.png)

![image-20201008175559172](img/image-20201008175559172.png)

选择JRE的路径

<img src="img/image-20201008175910715.png" alt="image-20201008175910715" style="zoom:80%;" />

<img src="img/image-20201008175935039.png" alt="image-20201008175935039" style="zoom:80%;" />

![image-20201008180215727](img/image-20201008180215727.png)

#### 1.3 配置环境变量

桌面图标“计算机”（或者“我的电脑”）右击，单击“属性”；

<img src="img/20190313171648807.png" alt="img" style="zoom:50%;" />

选择高级系统设置

![image-20201008180753428](img/image-20201008180753428.png)

选择高级-环境变量

<img src="img/image-20201008180853832.png" alt="image-20201008180853832" style="zoom:80%;" />

在弹出的“环境变量”框中，选择下方“系统变量（S）”下面的按钮“新建”；

<img src="img/image-20201008181041178.png" alt="image-20201008181041178" style="zoom:80%;" />

设置环境变量，3个变量都设置好；

![image-20201008181150226](img/image-20201008181150226.png)

需要设置3个环境变量，详情如下：

JAVA_HOME
D:\Program Files\Java\jdk1.8.0_131 （刚才JDK的安装目录）

Path
%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;（JRE安装到了D:\Program Files\Java\jdk1.8.0_131\jre）

![image-20201008181534252](img/image-20201008181534252.png)

CLASSPATH
.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar （第1个分号前面还有个点，别丢了）

![image-20201008181450109](img/image-20201008181450109.png)

设置好后点击“确认”

<img src="img/image-20201008181650901.png" alt="image-20201008181650901" style="zoom:80%;" />

#### 1.4验证jdk安装是否成功

win+R，输入cmd，回车，打开cmd.exe；

![image-20201008182017347](img/image-20201008182017347.png)

输入 java -version 或者 javac -version，能顺利显示安装的版本即可；

![image-20201008181858844](img/image-20201008181858844.png)

### 2. Maven

#### 1. 1下载

官网下载地址：http://maven.apache.org/download.cgi
![image-20200501090716122](img/image-20200501090716122.png)

下载最新版本的即可

#### 1.2.安装

下载完成后，将下载到的压缩包解压即可。

文件目录：
![image-20200501090924343](img/image-20200501090924343.png)

#### 1.3. 配置

##### 1.3.1 环境变量配置

添加系统变量：

- 变量名：

  ```
  M2_HOME
  ```

  

- 变量值：Maven解压目录

![image-20200501091204946](img/image-20200501091204946.png)

##### 1.3.2 编辑Path环境变量

在Path环境变量处，增加新的变量值：

- %M2_HOME%\bin

![image-20200501091342773](img/image-20200501091342773.png)

##### 1.3.3 cmd窗口测试

打开cmd，输入mvn -v检测

![image-20200501091526007](img/image-20200501091526007.png)

##### 1.3.4 创建本地仓库

Maven的作用可以简单的理解为下载项目所需jar包，既然需要下载jar包，那么就要指定jar包的下载目录，即本地仓库

1. 在自己选定的位置创建文件夹，作为本地仓库，来存放jar包
   ![image-20200501091854204](img/image-20200501091854204.png)
   local为我自己的本地仓库

2. 在Maven的配置文件seeting.xml文件中，添加上本地仓库的目录

   1. IDEA打开Maven目录下conf下的settings.xml文件
      可以看到，settings.xml文件中多数都为注释部分

   2. 在settings标签下添加本地仓库的绝对路径

      ```xml
      <localRepository>本地仓库的绝对路径</localRepository>
      ```

      ![image-20200501092523955](img/image-20200501092523955.png)

##### 1.3.5 增加国内镜像

增加国内镜像，可以大幅提高jar包下载速度

1. IDEA打开IDEA打开Maven目录下conf下的settings.xml文件

2. 在<mirrors>标签中增加如下代码：

   ```xml
   <mirror>
   <id>alimaven</id>
   <mirrorOf>central</mirrorOf>
   <name>aliyun maven</name>
   <url>http://maven.aliyun.com/nexus/content/groups/public/</url>
   </mirror>
   ```

#### 4. IDEA相关设置

Ctrl + Alt + S打开设置，搜索Maven，出现下图界面：
![image-20200501093009157](img/image-20200501093009157.png)

- Maven home directory：Maven安装目录
- User settings file：Maven目录下conf下的settings.xml文件
- Local repository：本地仓库路径（如果settings.xml文件书写正常，本地仓库可被自动识别）

### 2. SVN配置

1. 下载

官网下载地址：https://tortoisesvn.net/downloads.zh.html
![image-20200501093403102](img/image-20200501093403102.png)

选择对应32位或64位

#### 2. 安装

安装过程非常简单，但需要注意一点：选择command line cilent tools

![image-20200501093639428](img/image-20200501093639428.png)

这一项默认是没有选择的，一定要自己手动选择！

#### 3. IDEA相关设置

Ctrl + Alt + S打开设置，Versin Control--->Subversion
![image-20200501094258560](img/image-20200501094258560.png)

在右边，输入svn，下方的Use custom configuration directory ，IDEA会自动识别。

### 3. Tomcat

#### 1. 下载

官网下载地址：https://tomcat.apache.org/download-90.cgi
![image-20200501095048856](img/image-20200501095048856.png)

#### 2. 安装

将下载得到的压缩包解压，即可完成安装。
![image-20200501095134916](img/image-20200501095134916.png)



#### 3. 配置

3.1 环境变量配置

添加系统变量：

- 变量名：CATALINA_HOME
- 变量值：Tomcat解压目录

![image-20200501095425943](img/image-20200501095425943.png)

##### 3.2 编辑Path环境变量

在Path环境变量处，增加新的变量值：

- %CATALINA_HOME%\bin
- %CATALINA_HOME%\lib

##### 3.3 Tomcat启动测试

双击Tomcat安装目录下bin下startup.bat
![image-20200501095814342](img/image-20200501095814342.png)

出现上图界面，即安装配置完成。

### 4. IDEA相关设置

1. 点击run下的Edit Configurations
   ![image-20200501100253595](img/image-20200501100253595.png)

2. 选择左上角的+号，然后选择local Tomcat
   ![image-20200501100747328](img/image-20200501100747328.png)

3. 在Name处，填写自己想要选取的名字，然后点击Configure
   ![image-20200501100947131](img/image-20200501100947131.png)

4. 在Tomcat Home处，选择Tomcat的安装目录；在Tomcat base directory处选择Tomcat的安装目录
   ![image-20200501101102768](img/image-20200501101102768.png)

   完成配置。

   ### Anaconda搭建Python开发环境

   参考来源：
   https://blog.csdn.net/qq_326324545/article/details/84522368
   https://blog.csdn.net/sizhi_xht/article/details/80964099
   https://zhuanlan.zhihu.com/p/37611680
   https://blog.csdn.net/ben1010101010/article/details/90897405

   欢迎讨论交流，如有侵权请联系本人！

   1. 下载并安装Anaconda：

      ```bash
      # 下载Linux平台版本Anaconda，下例网页链接版本为Anaconda 2019.03 Python 3.7 version 64-Bit (x86) Installer for Linux
      wget https://repo.anaconda.com/archive/Anaconda3-2019.03-Linux-x86_64.sh
      # 安装Anaconda，建议直接安装，不使用root权限，除非你是系统的管理员
      bash Anaconda3-2019.03-Linux-x86_64.sh
      ```

      以下为安装过程中的选项说明：

      ```text
      # 确认安装位置，默认位置为用户个人文件夹下的anaconda3文件夹
      Anaconda3 will now be installed into this location...
      [/home/current_user/anaconda3] >>>
      # 确认是否由Anaconda进行终端的初始化，一般选择是，否则无法使用虚拟环境
      Do you wish the installer to initialize Anaconda3 by running conda init? [yes|no]
      [no] >>> yes
      ```

      安装完成后，Anaconda会设置终端开启时，自动进入base虚拟环境，我们需要取消这一设置，因为虚拟环境是可嵌套的，在base环境中再进入虚拟环境可能会产生不可控的问题。使用以下命令取消这一行为：

      ```bash
      conda config --set auto_activate_base false
      ```

   2. 创建并使用虚拟环境：

      建议不要直接使用本地的Python环境，而是创建自己的虚拟环境。这样做有两点好处，一是能够在虚拟Anaconda环境中进行随意的定制而不用担心破坏原本的终端环境，二是熟悉了虚拟环境的用法之后，可以制作多个虚拟环境用于不同的任务，这样就可以使得对于依赖包的版本要求不同的项目可以共存在一个账号上。

      ```bash
      # 创建名为my_virtual_env的虚拟环境，并安装Python3.7及必要的Python库。此命令也可以不指定Python版本，但会创建一个不含Python的空环境，如果没有特殊需求，请直接指定Python版本
      conda create -n my_virtual_env python=3.7
      # 激活虚拟环境
      conda activate my_virtual_env
      # 关闭虚拟环境
      conda deactivate
      # 列出所有存在的虚拟环境名称
      conda env list
      # 删除指定虚拟环境，如果为空环境则此命令失效（也就是未指定Python版本的时候）
      conda remove -n my_virtual_env --all
      # 删除指定虚拟环境，无论此环境是否为空
      conda env remove -n my_virtual_env
      # 安装Anaconda收录的Python包，使用此命令Anaconda会自动检查新安装包与已安装包之间是否有依赖库版本冲突
      conda install package
      # 安装所有Python收录的包，包括Anaconda未收录的Python包，不会检查依赖库版本冲突
      pip install package
      # 查找相关包的所有收录版本
      conda search package
      # 导出虚拟环境配置表及使用配置表文件创建虚拟环境
      conda env export > conda_env.yaml
      conda env create -f conda_env.yaml
      ```

   3. 在`~/.bash_aliases`中添加以下内容，以便以后快速开启关闭虚拟环境：

      ```bash
      alias jumpin='conda activate my_virtual_env'
      alias crawlout='conda deactivate'
      ```

      添加完成后使用`source ~/.bash_aliases`命令重新执行该文件，之后就可以使用定制命令操作虚拟环境的激活和关闭

      

##  附录2：运行环境搭建



### 1.1 云服务环境

```
https://docs.qingcloud.com/product/quick_start/   青云帮助文档

青云提供了两种组网方式：基础网络、私有网络（VxNet）。 前者是一个由青云系统维护的全局网络，后者是用户各自自行组建的网络。

基础网络的好处是简单、无需用户做任何配置与管理，即可直接使用， 但正因为它是全局网络，所以其安全保障是依靠防火墙（Security Group）来实现的。 与之相对应，私有网络需要用户创建并管理 （当然，为了简化管理，青云提供了路由器来帮助用户）， 但私有网络之间是100%隔离的，以满足对安全的100%追求。
```





1.2 配置YUM源

yum仓库就是使用yum命令下载软件的镜像地址。

我们通常使用 yum install 命令来在线安装 linux系统的软件， 这种方式可以自动处理依赖性关系，并且一次安装所有依赖的软体包，但是经常会遇到从国外镜像下载速度慢，无法下载的情况。那么此时我们就需要把我们的yum 源改为国内的镜像。

yum的配置文件
yum 的配置文件在 /etc/yum.repos.d 目录下, 其中有多个配置文件,每一个配置文件中都可以配置一个或多个repository, 但是最终会被合并为一个交给系统，所以多个文件只是为了方便管理。

2、yum仓库配置
下面提供了 阿里和 清华大学 两个镜像仓库配置操作说明，=实际使用时，选择其中一个配置即可。

```
yum install vim   #安装VIM编辑器
yum install wget   #安装下载工具
```

1）、备份，将 CentOS-Base.repo 为CentOS-Base.repo.backup

```
mv   /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup

 cp  /etc/yum.repos.d/CentOS-Base.repo.bak /etc/yum.repos.d/CentOS-Base.repo
```

（2）、下载新的 http://mirrors.aliyun.com/repo/Centos-7.repo,并命名为CentOS-Base.repo

```
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
或者
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
```

（3）、清除缓存

```
yum clean all # 清除系统所有的yum缓存
yum makecache # 生成yum缓存
yum update

yum install vim
```

### 1.2 Docker搭建

#### 1.2.1 安装流程

1、Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。

通过 **uname -r** 命令查看你当前的内核版本

```
 $ uname -r
```

2、使用 `root` 权限登录 Centos。确保 yum 包更新到最新。

```
$ sudo yum update
```

![image-20200714203609004](./img/image-20200714203609004.png)

3、卸载旧版本(如果安装过旧版本的话)

```
$ sudo yum remove docker  docker-common docker-selinux docker-engine
```

4、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的

```
$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2
```

5、设置yum源

```
$ sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
```

 ![img](https://images2017.cnblogs.com/blog/1107037/201801/1107037-20180128094640209-1433322312.png)

6、可以查看所有仓库中所有docker版本，并选择特定版本安装

```
$ yum list docker-ce --showduplicates | sort -r
```

![img](https://images2017.cnblogs.com/blog/1107037/201801/1107037-20180128095038600-772177322.png)

7、安装docker

```
$ sudo yum install docker-ce  #由于repo中默认只开启stable仓库，故这里安装的是最新稳定版17.12.0

```

 ![img](https://images2017.cnblogs.com/blog/1107037/201801/1107037-20180128103448287-493824081.png)

8、启动并加入开机启动

```
$ sudo systemctl start docker
$ sudo systemctl enable docker
```

9、验证安装是否成功(有client和service两部分表示docker安装启动都成功了)

```
$ docker version
```

![img](https://images2017.cnblogs.com/blog/1107037/201801/1107037-20180128104046600-1053107877.png)

####  1.2.2 Docker常用命令

1. 列出所有容器 ID

```
docker ps -aq
```

2. 停止所有容器

```
docker stop $(docker ps -aq)
```

3. 停止单个容器

```
docker stop 要停止的容器名
```

4. 删除所有容器

```
docker rm $(docker ps -aq)
```

5. 删除单个容器

```
docker rm 要删除的容器名
```

6. 删除镜像

```
删除指定
docker rmi 6a8e2d5dd257  -f

删除所有image
docker rmi $(docker images -q)
```

7. 要让docker 的容器自动在开机启动，

```
docker run 指令中加入 --restart=always 就行。
sudo docker run --restart=always .....

如果创建时未指定 --restart=always ,可通过update 命令设置
docker update --restart=always xxx
```

8. 进入容器内部执行命令

```
 docker exec -it 6f6679679be8   /bin/bash
```



#### 1.2.3 Docker使用

```
1.镜像安装：
docker pull tomcat
docker pull nginx

2.启动容器
docker run -it --name webdemo -p 80:8080 tomcat /bin/bash
启动一个交互式的容器，名字是webdemo，-p 80:8080表示将容器的8080端口映射到主机的80端口，这样我们只要访问主机的80端口就可以访问到容器的服务了。

docker run -d -p 8088:8080 tomcat
docker run -d -p 8089:8080 tomcat
安装两个实例，端口分别为8088,8089

docker run -p 8080:80 -d docker.io/nginx
安装nginx，端口为8080。在测试的过程中，发现ubuntu上对80端口有限制，不能直接访问，所以映射为8080

3.如何将文件从主机复制到容器中：

从主机复制到容器 sudo docker cp host_path containerID:container_path
从容器复制到主机 sudo docker cp containerID:container_path host_path

长的字符串是容器的id
 
 
 4.docker 下修改参数：
 
 docker cp 3c8d188f7fb48:/etc/mysql/mysql.conf.d/mysqld.cnf /home/
修改文件内容，添加参数行 log_bin=on
docker cp /home/mysqld.cnf 3c8d188f7fb48:/etc/mysql/mysql.conf.d/mysqld.cnf
docker reload 3c8d188f7fb48
```

### 1.3搭建Maven仓库

​		maven的仓库分为本地仓库，远程仓库和私服仓库。私服仓库一般是公司内部私有的，内部进行维护的。公司员工连接私服，从私服中下载jar，或者将自身的jar传到私服上。私服还可以从中央仓库下载jar，当私服中没用jar的时候，就会从中央仓库下载。

​	常用的私服有：[Apache Archiva](http://archiva.apache.org/index.cgi)，[Artifactory](http://www.jfrog.com/home/v_artifactory_opensource_overview/)，[Sonatype Nexus](http://www.sonatype.org/nexus/)。这里我们使用 Sonatype Nexus。



![img](https://img2018.cnblogs.com/blog/1534147/201910/1534147-20191007102334014-1695193385.png)

```
https://www.cnblogs.com/yhaing/p/8568043.html
```



#### 1.3.1Maven 的概念



Maven是一个软件项目管理工具，通过它可便捷的管理项目的生命周期。即项目的jar包依赖，开发，测试，发布打包、版本等。虽然目前的IDE工具（如eclipse）可管理开发、发布、打包工作，但还没有形成一套完成的体系。

Maven有以下几个功能特点：

1、 jar包依赖

　　这个也许会maven最突出的特点。使用maven进行开发时，不需要上网单独下载jar包，只需要在配置文件pom.xml中配置jar包的依赖关系，就可以自动下载jar包到我们的项目中（在联网情况下，maven可自动从https://repo.maven.apache.org/maven2中下载所需要的jar包。如果无法联网，可搭建基于Nexus私服的中央库并提供jar包下载）。这样，别人开发或者使用这个工程时，不需要来回的拷贝jar包，只需要复制这个pom.xml就可以自动的下载这些jar包。而且，我们自己下载jar包，还有可能造成版本的不一致，这样在协同开发的过程中就有可能造成代码运行的不一致。通过使用maven精确的匹配jar包，就不会出现这种问题了。

以下是一个项目的pom.xml中对jar包依赖的描述：



       <!-- spring需要的jar包 --> 
       <dependency> 
           <groupId>org.springframework</groupId> 
           <artifactId>spring-context</artifactId> 
           <version>3.2.4.RELEASE</version> 
           <type>jar</type> 
        </dependency> 



2 项目坐标

Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标，长的其实很普通，就是简单的xml而已。比如，以下为一个web项目的项目坐标描述信息（在该项目的pom.xml文件的开始位置）

```
  <groupId>com.nci</groupId>
  <artifactId>first_maven</artifactId>
  <version>1.0.0</version>
<packaging>war</packaging>
```

各字段说明：

  groupId：所述的项目名称，由于有的项目并不是一个jar包构成的，而是由很多的jar包组成的。因此这个groupId就是整个项目的名称。

artifactId：包的名称。

version：版本号。

packaging：包的类型，一般都是jar，也可以是war之类的。如果不填，默认就是jar。War代表web项目。


#### 1.3.2 私服搭建

​	搭建私有仓库，放到青云上。VPN登录上来。Docker容器比较

1. 执行以下命令，会自动从hub.docker.com下载最新的nexus镜像，然后启动一个名为nexus的容器，当前电脑的8081端口被映射到容器的8081端口： 
   `docker run -idt -p 8081:8081 --name nexus -v /home/data/nexus:/sonatype-work sonatype/nexus `

2. 执行命令

   docker logs -f nexus

   查看容器日志滚动信息，显示如下信息时nexus启动成功：

    

   ```
   2018-01-20 03:37:42,187+0000 INFO [jetty-main-1] org.sonatype.nexus.webresources.internal.WebResourceServiceImpl - Discovered 1971 resources 
   2018-01-20 03:37:42,189+0000 INFO [jetty-main-1] org.sonatype.nexus.webresources.internal.WebResourceServlet - Max-age: 30 days (2592000 seconds) 
   2018-01-20 03:37:42,304+0000 INFO [jetty-main-1] org.sonatype.nexus.bootstrap.jetty.InstrumentedSelectChannelConnector - Metrics enabled 
   2018-01-20 03:37:42,348+0000 INFO [jetty-main-1] org.eclipse.jetty.server.AbstractConnector - Started InstrumentedSelectChannelConnector@0.0.0.0:8081 
   2018-01-20 03:37:42,352+0000 INFO [jetty-main-1] org.sonatype.nexus.bootstrap.jetty.JettyServer - Running 
   2018-01-20 03:37:42,352+0000 INFO [main] *SYSTEM org.sonatype.nexus.bootstrap.jetty.JettyServer - Started 
   ```

   查看当前电脑的/usr/local/work/dockermaven目录，可以看到nexus容器中应用的相关文件已经在此处创建，如下图： 
   ![这里写图片描述](http://img.blog.csdn.net/20180120124738375?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9saW5nX2NhdmFscnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

3. 在浏览器输入地址访问nexus：http://192.168.18.110:8081/nexus

4. 对maven私有仓库的使用者来说，完全感受不到实际安装和在docker安装私有仓库的区别，您可以像前两章的实战那样，体验此仓库的jar缓存和保存二方库的服务；

5. 发布一个二方库到nexus，deploy成功后，可以在nexus上看到新的二方库，如下图所示，(deploy之前记得在nexus上设置允许上传，并且设置deployment账号的密码，详见上一章)： 
   ![这里写图片描述](http://img.blog.csdn.net/20180120125756545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYm9saW5nX2NhdmFscnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

至此，实战maven私有仓库三部曲系列就全部结束了，希望其中的实战和demo能够助您一臂之力；



#### 1.3.3Nexus 的仓库分类

·    要用于部署无法从公共仓库获取的构件（如 oracle 的 JDBC 驱动）以及自己或第三方的项目构件。nexus内置了三个host库。

3rd party：第三方库，如mysql 的jdbc驱动jar

Release：自己开发的release版本的jar

Snapshots：自己开发的snapshot版本的jar（可理解为测试版本）


### 1.4 搭建Gitlab服务器

#### 1.4.1 gitlab以及使用

##### 1.gitlab镜像拉取



```ruby
# gitlab-ce为稳定版本，后面不填写版本则默认pull最新latest版本
$ docker pull gitlab/gitlab-ce
```

拉取镜像

##### 2.运行gitlab镜像



```csharp
$ docker run -d  -p 8082:80 -p 8083:443 -p 8084:22  --name gitlab --restart always -v /home/data/gitlab/config:/etc/gitlab -v /home/data/gitlab/logs:/var/log/gitlab -v /home/data/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce
# -d：后台运行
# -p：将容器内部端口向外映射
    22: SSH访问端口，
    80：Http 访问端口，
    443：Https 访问端口，
# --name：命名容器名称
# -v：将容器内数据文件夹或者日志、配置等文件夹挂载到宿主机指定目录
    
    
```

运行成功后出现一串字符串



![img](https:////upload-images.jianshu.io/upload_images/15087669-5818ed22c0bc1ee7.png?imageMogr2/auto-orient/strip|imageView2/2/w/467/format/webp)

运行成功:

http://192.168.18.101:8082/

8082:80 -p 8083:443 -p 8084:22

![image-20200713230601494](./img/image-20200713230601494.png)

此处设置密码，用户为root，最高管理权限。



##### 3.配置

按上面的方式，gitlab容器运行没问题，但在gitlab上创建项目的时候，生成项目的URL访问地址是按容器的hostname来生成的，也就是容器的id。作为gitlab服务器，我们需要一个固定的URL访问地址，于是需要配置gitlab.rb（宿主机路径：/home/data/gitlab/config/gitlab.rb）。



```uby
# gitlab.rb文件内容默认全是注释
$ vim /home/gitlab/config/gitlab.rb
```



```ruby
# 配置http协议所使用的访问地址,8082---->80
external_url 'http://192.168.18.201:8082'   #外部IP监听端口
nginx['listen_port'] = 80    #容器监听端口，默认80
# https需要下面这句
nginx['redirect_http_to_https_port'] = 8082   

# 配置ssh协议所使用的访问地址和端口
gitlab_rails['gitlab_ssh_host'] = '192.168.18.201'
gitlab_rails['gitlab_shell_ssh_port'] = 8084 # 此端口是run时22端口映射的8084端口 

```



以下文件是自动生成的，不能进行修改。

```
修改/home/data/gitlab/data/gitlab-rails/etc/gitlab.yml

vi gitlab.yml

找到关键字 * ## Web server settings *
将host的值改成映射的外部主机ip地址和端口
```



修改好后保持，退出，进入容器内，应用重新配好的配置并重启GitLab,然后查看GitLab的状态。

```
docker exec -ti gitlab /bin/bash

gitlab-ctl reconfigure #花时间比较多
gitlab-ctl restart
gitlab-ctl status

```



支持ssl(未测试)

```
vi /etc/gitlab/gitlab.rb

nginx['ssl_certificate'] = "/var/opt/gitlab/elooyoo.com/fullchain.pem"
nginx['ssl_certificate_key'] = "/var/opt/gitlab/elooyoo.com/privkey.pem"
nginx['redirect_http_to_https'] = true

```



```ruby
# 重启gitlab容器
$ docker restart gitlab
```

此时项目的仓库地址就变了。如果ssh端口地址不是默认的22，就会加上ssh:// 协议头
 打开浏览器输入ip地址(因为我的gitlab端口为80，所以浏览器url不用输入端口号，如果端口号不是80，则打开为：ip:端口号)

##### 4.创建一个项目

第一次进入要输入新的root用户密码，设置好之后确定就行

![img](https:////upload-images.jianshu.io/upload_images/15087669-6b04cfddeccf17bf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

gitlab页面

下面我们就可以新建一个项目了，点击Create a project

![img](https:////upload-images.jianshu.io/upload_images/15087669-2a40551dc13c2826.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

Create a project

创建完成后：



![img](https:////upload-images.jianshu.io/upload_images/15087669-0dd085723ef61677.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

创建完成！

#### 1.4.2 gitlab-runner安装





### 1.5 搭建Jenkins服务器



1. 使用docker 安装jenkins

```
docker run -p 8086:8080 -p 8087:50000 -v /home/data/jenkins/data:/var/jenkins_home jenkinsci/blueocean
```

docker 运行后， 执行docker logs -f myjenkins时报错：

touch: cannot touch ‘/var/jenkins_home/copy_reference_file.log’: Permission denied
Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?

需要修改下目录权限, 因为当映射本地数据卷时，/home/docker/jenkins目录的拥有者为root用户，而容器中jenkins user的uid为1000
执行如下命令即可：

chown -R 1000:1000 /home/docker/jenkins


2. 访问jenkins地址 8086



![image-20200715154324682](./img/image-20200715154324682.png)

 

注意：第一次启动的时候正在加载jenkins大概会等待3-10分钟。

3.解锁jenkins

 ![img](https://img2018.cnblogs.com/blog/1555009/201905/1555009-20190522001149401-1287019274.png)



```
[root@i-qvtplnds data]# docker exec -it jenkisci/blueocen /bin/bash
Error: No such container: jenkisci/blueocen
[root@i-qvtplnds data]# ls
com.cloudbees.hudson.plugins.folder.config.AbstractFolderConfiguration.xml  jenkins.telemetry.Correlator.xml  secret.key.not-so-secret
config.xml                                                                  jobs                              secrets
copy_reference_file.log                                                     logs                              updates
hudson.model.UpdateCenter.xml                                               nodeMonitors.xml                  userContent
hudson.plugins.git.GitTool.xml                                              nodes                             users
identity.key.enc                                                            plugins                           war
jenkins.install.UpgradeWizard.state                                         secret.key                        workflow-libs
[root@i-qvtplnds data]# cd sercrets
-bash: cd: sercrets: No such file or directory
[root@i-qvtplnds data]# cd secret
-bash: cd: secret: No such file or directory
[root@i-qvtplnds data]# cd secrets
[root@i-qvtplnds secrets]# ls
filepath-filters.d    jenkins.model.Jenkins.crumbSalt  org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY  whitelisted-callables.d
initialAdminPassword  master.key                       slave-to-master-security-kill-switch
[root@i-qvtplnds secrets]# cat initialAdminPassword 
87eab010550c42bba8b479e5b50955de
[root@i-qvtplnds secrets]# 

```

 



![image-20200715155149523](./img/image-20200715155149523.png)

 ![img](https://img2018.cnblogs.com/blog/1555009/201905/1555009-20190522001215026-1128465794.png)

 

docker exec -it 7f485bd95c3b  /bin/bash 进入jenkins容器 

cat /var/jenkins_home/secrets/initialAdminPassword

### 1.6 搭建Tomcat服务器

3. 获取Tomcat8版本

   docker pull tomcat:8  

   

4. 启动tomcat

```
 docker run -d -p 8088:8080 tomcat
```

 -d表示后台运行，-p端口映射，前面的8088是外围访问端口（也就是本机ip对外开放的端口），后面8080是docker容器内部的端口。



http://localhost:8080

出现以下错误：**资源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示。**

这是容器中的webapps为空导致的，执行以下命令进入容器交互模式：

```
 docker exec -it 6f6679679be8   /bin/bash
```



```
root@6f6679679be8:/usr/local/tomcat# cd webapps
//将webapps.dist内容拷贝过来
root@6f6679679be8:/usr/local/tomcat/webapps# cp -r ../webapps.dist/*  ./
root@6f6679679be8:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager  webapps.dist


```

执行正常：

![image-20200713221551489](./img/image-20200713221551489.png)



挂在宿主机器目录到容器，持久化存储：

1. tomcat 容器 webapps 路径：/usr/local/tomcat/webapps

2. 在宿主目录下新建目录 /home/data/tomcat/webapps

3. 停止 tomcat 容器并删除该容器

   1. 查找容器的 CONTAINER ID

      ```
      docker ps -a 
      ```

   2. 停止容器

      ```
       docker stop CONTAINER_ID
      ```

   3. 删除容器

      ```
      docker rm CONTAINER_ID 
      ```

4. 重新跑一个 tomcat 容器并挂载宿主目录

   ```
   docker run --name tomcat-service -d -p 8080:8080 -v /home/data/tomcat/webapps:/usr/local/tomcat/webapps tomcat  
   
   docker run --name tomcat-service1 -d -p 8090:8080 -v /home/data/tomcat/webapps:/usr/local/tomcat/webapps tomcat
   
   docker run --name tomcat-service2 -d -p 8091:8080 -v /home/data/tomcat/webapps:/usr/local/tomcat/webapps tomcat
   
   
   docker run --name tomcat-service3 -d -p 8092:8080 -v /home/data/tomcat/webapps:/usr/local/tomcat/webapps tomcat
   ```



   5.此时访问仍然出错**资源服务器未能找到目标资源的表示或者是不愿公开一个已经存在的资源表示。**

进入容器内容拷贝内容

```
root@1a8599cd150c:/usr/local/tomcat# cd webapps
root@1a8599cd150c:/usr/local/tomcat/webapps# cd webapps
bash: cd: webapps: No such file or directory
root@1a8599cd150c:/usr/local/tomcat/webapps# cp ../webapps.dist/* ./
cp: -r not specified; omitting directory '../webapps.dist/ROOT'
cp: -r not specified; omitting directory '../webapps.dist/docs'
cp: -r not specified; omitting directory '../webapps.dist/examples'
cp: -r not specified; omitting directory '../webapps.dist/host-manager'
cp: -r not specified; omitting directory '../webapps.dist/manager'
root@1a8599cd150c:/usr/local/tomcat/webapps# cp -r ../webapps.dist/* ./
root@1a8599cd150c:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
root@1a8599cd150c:/usr/local/tomcat/webapps# 

```

回到宿主机下面，进行webapps，发现内容实际拷贝到宿主机器下面

```
[root@i-s21hd6yt tomcat]# ls
webapps
[root@i-s21hd6yt tomcat]# cd webapps/
[root@i-s21hd6yt webapps]# ls
docs  examples  host-manager  manager  ROOT
[root@i-s21hd6yt webapps]# 

```

访问http://localhost :8080 可以正常访问。





### 1.7搭建Mysql数据库

```
https://blog.csdn.net/weixin_39791387/article/details/93375560
```



```
docker run -p 3306:3306 --name mysql  -v /home/data/mysql/conf:/etc/mysql  -v /home/data/mysql/logs:/var/log/mysql  -v /home/data/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7


docker run -p 3307:3306 --name mysql3307  -v /home/data/mysql3307/conf:/etc/mysql  -v /home/data/mysql3307/logs:/var/log/mysql  -v /home/data/mysql3307/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7


docker run -p 3308:3306 --name mysql3308  -v /home/data/mysql3308/conf:/etc/mysql  -v /home/data/mysql3308/logs:/var/log/mysql  -v /home/data/mysql3308/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7


docker run -p 3309:3306 --name mysql3309  -v /home/data/mysql3309/conf:/etc/mysql  -v /home/data/mysql3309/logs:/var/log/mysql  -v /home/data/mysql3309/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7

测试库：

docker run -p 3310:3306 --name mysql3310  -v /home/data/mysql3310/conf:/etc/mysql  -v /home/data/mysql3310/logs:/var/log/mysql  -v /home/data/mysql3310/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7

docker run -p 3311:3306 --name mysql3311  -v /home/data/mysql3311/conf:/etc/mysql  -v /home/data/mysql3311/logs:/var/log/mysql  -v /home/data/mysql3311/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7


docker run -p 3312:3306 --name mysql3311  -v /home/data/mysql3312/conf:/etc/mysql  -v /home/data/mysql3312/logs:/var/log/mysql  -v /home/data/mysql3312/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=123456  -d mysql:5.7

```



### 1.8搭建WEB服务器集群

​    nginx +tomcat   



​		搭建Nginx

```
docker pull nginx
docker run --name nginx-test -p 8080:80 -d nginx
```

运行结果如下：



![image-20200714193027094](./img/image-20200714193027094.png)



### 1.9 安装可视化工具grafana



```
docker run -d -p 8085:3000 --name=grafana -v /home/data/grafana/data:/var/lib/grafana -v /home/data/grafana/conf:/usr/share/grafana/conf grafana/grafana
```

选择挂载数据文件(/var/lib/grafana)和配置文件(/usr/share/grafana/conf)。前者存放panels、datasoure、页面等数据，后者为配置文件，挂载后可以直接在宿主机器上修改，重启容器后生效





### 1.10 Redis安装部署



##### 4.1 安装redis



###### 第一步：下载redis安装包

wget http://download.redis.io/releases/redis-4.0.6.tar.gz

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[root@iZwz991stxdwj560bfmadtZ local]# wget http://download.redis.io/releases/redis-4.0.6.tar.gz
--2017-12-13 12:35:12--  http://download.redis.io/releases/redis-4.0.6.tar.gz
Resolving download.redis.io (download.redis.io)... 109.74.203.151
Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 1723533 (1.6M) [application/x-gzip]
Saving to: ‘redis-4.0.6.tar.gz’

100%[==========================================================================================================>] 1,723,533    608KB/s   in 2.8s   

2017-12-13 12:35:15 (608 KB/s) - ‘redis-4.0.6.tar.gz’ saved [1723533/1723533]
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

###### 第二步：解压压缩包

tar -zxvf redis-4.0.6.tar.gz

```
[root@iZwz991stxdwj560bfmadtZ local]# tar -zxvf redis-4.0.6.tar.gz
```

 

###### 第三步：yum安装gcc依赖

yum install gcc

```
[root@iZwz991stxdwj560bfmadtZ local]# yum install gcc
```

遇到选择,输入y即可

 

###### 第四步：redis解压目录下

cd redis-4.0.6

```
[root@iZwz991stxdwj560bfmadtZ local]# cd redis-4.0.6
```

 

###### 第五步：编译安装

make MALLOC=libc　　

```
[root@iZwz991stxdwj560bfmadtZ redis-4.0.6]# make MALLOC=libc
```

 

将/usr/local/redis-4.0.6/src目录下的文件加到/usr/local/bin目录

cd src && make install

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[root@iZwz991stxdwj560bfmadtZ redis-4.0.6]# cd src && make install
    CC Makefile.dep

Hint: It's a good idea to run 'make test' ;)

  

```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

#### 4.2启动redis的三种方式

 

先切换到redis src目录下

```
[root@iZwz991stxdwj560bfmadtZ redis-4.0.6]# cd src
```

 

##### 1、直接启动redis

./redis-server

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
[root@iZwz991stxdwj560bfmadtZ src]# ./redis-server
18685:C 13 Dec 12:56:12.507 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
18685:C 13 Dec 12:56:12.507 # Redis version=4.0.6, bits=64, commit=00000000, modified=0, pid=18685, just started
18685:C 13 Dec 12:56:12.507 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf
                _._                                                  
           _.-``__ ''-._                                             
      _.-``    `.  `_.  ''-._           Redis 4.0.6 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._                                   
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 18685
  `-._    `-._  `-./  _.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |           http://redis.io        
  `-._    `-._`-.__.-'_.-'    _.-'                                   
 |`-._`-._    `-.__.-'    _.-'_.-'|                                  
 |    `-._`-._        _.-'_.-'    |                                  
  `-._    `-._`-.__.-'_.-'    _.-'                                   
      `-._    `-.__.-'    _.-'                                       
          `-._        _.-'                                           
              `-.__.-'                                               

18685:M 13 Dec 12:56:12.508 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
18685:M 13 Dec 12:56:12.508 # Server initialized
18685:M 13 Dec 12:56:12.508 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.
18685:M 13 Dec 12:56:12.508 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never > /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.
18685:M 13 Dec 12:56:12.508 * Ready to accept connections　　
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

如上图：redis启动成功，但是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。

 

按 ctrl + c可以关闭窗口。

　　

##### 2、以后台进程方式启动redis

第一步：修改redis.conf文件

将

```
daemonize no
```

 

修改为

```
daemonize yes
```

　

第二步：指定redis.conf文件启动

```
./redis-server /usr/local/redis-4.0.6/redis.conf
[root@iZwz991stxdwj560bfmadtZ src]# ./redis-server /usr/local/redis-4.0.6/redis.conf 
18713:C 13 Dec 13:07:41.109 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
18713:C 13 Dec 13:07:41.109 # Redis version=4.0.6, bits=64, commit=00000000, modified=0, pid=18713, just started
18713:C 13 Dec 13:07:41.109 # Configuration loaded
```

 

第三步：关闭redis进程

首先使用ps -aux | grep redis查看redis进程

```
[root@iZwz991stxdwj560bfmadtZ src]# ps -aux | grep redis
root     18714  0.0  0.1 141752  2008 ?        Ssl  13:07   0:00 ./redis-server 127.0.0.1:6379
root     18719  0.0  0.0 112644   968 pts/0    R+   13:09   0:00 grep --color=auto redis
```

 

使用kill命令杀死进程

```
[root@iZwz991stxdwj560bfmadtZ src]# kill 18714
```

　 

##### 3、设置redis开机自启动

1、在/etc目录下新建redis目录

mkdir redis

```
[root@iZwz991stxdwj560bfmadtZ etc]# mkdir redis
```

 

2、将/usr/local/redis-4.0.6/redis.conf 文件复制一份到/etc/redis目录下，并命名为6379.conf　　

```
[root@iZwz991stxdwj560bfmadtZ redis]# cp /usr/local/redis-4.0.6/redis.conf /etc/redis/6379.conf
```

 

3、将redis的启动脚本复制一份放到/etc/init.d目录下

```
[root@iZwz991stxdwj560bfmadtZ init.d]# cp /usr/local/redis-4.0.6/utils/redis_init_script /etc/init.d/redisd
```

 

4、设置redis开机自启动

先切换到/etc/init.d目录下

然后执行自启命令

```
[root@iZwz991stxdwj560bfmadtZ init.d]# chkconfig redisd on
service redisd does not support chkconfig　
```

 

看结果是redisd不支持chkconfig

解决方法：

使用vim编辑redisd文件，在第一行加入如下两行注释，保存退出

```
# chkconfig:   2345 90 10
# description:  Redis is a persistent key-value database
```

 

注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。

![img](https://images2017.cnblogs.com/blog/818973/201712/818973-20171213132912738-1132742812.png)

 

再次执行开机自启命令，成功

```
[root@iZwz991stxdwj560bfmadtZ init.d]# chkconfig redisd on
```

　

现在可以直接已服务的形式启动和关闭redis了

启动：

service redisd start　

```
[root@izwz991stxdwj560bfmadtz ~]# service redisd start
Starting Redis server...
2288:C 13 Dec 13:51:38.087 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
2288:C 13 Dec 13:51:38.087 # Redis version=4.0.6, bits=64, commit=00000000, modified=0, pid=2288, just started
2288:C 13 Dec 13:51:38.087 # Configuration loaded
```

 

关闭：

方法1：service redisd stop

```
[root@izwz991stxdwj560bfmadtz ~]# service redisd stop
Stopping ...
Redis stopped
```

 

方法2：redis-cli SHUTDOWN

　 

#### 4.3TimeSerials安装

安装信息

```
https://github.com/RedisTimeSeries/RedisTimeSeries
```



```
[root@i-wsad3ybt RedisTimeSeries]# ./system-setup.py 
/bin/python2 -m pip --version
pip 20.1.1 from /usr/lib/python2.7/site-packages/pip (python 2.7)
/bin/python2 -m pip install --disable-pip-version-check wheel
/bin/python2 -m pip install --disable-pip-version-check setuptools --upgrade
yum install -q -y git jq curl
yum groupinstall -y 'Development Tools'
yum install -q -y redhat-lsb-core
yum install -q -y lcov
Error: Nothing to do

```



解决办法 ：

```
方法一、更换源
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup1
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
运行 yum makecache 生成缓存

方法二、
用EPEL方式安装nginx：
sudo yum install epel-release
yum update
yum install -q -y lcov


```

————————————————
重新安装

```
[root@i-wsad3ybt RedisTimeSeries]# yum install -q -y lcov
Package lcov-1.13-1.el7.noarch already installed and latest version
[root@i-wsad3ybt RedisTimeSeries]# ./system-setup.py 
/bin/python2 -m pip --version
pip 20.1.1 from /usr/lib/python2.7/site-packages/pip (python 2.7)
/bin/python2 -m pip install --disable-pip-version-check wheel
/bin/python2 -m pip install --disable-pip-version-check setuptools --upgrade
yum install -q -y git jq curl
yum groupinstall -y 'Development Tools'
yum install -q -y redhat-lsb-core
yum install -q -y lcov
/bin/python2 -m pip install --disable-pip-version-check git+https://github.com/RedisLabs/RAMP@master
/bin/python2 -m pip install --disable-pip-version-check -r tests/requirements.txt
/bin/python2 -m pip install --disable-pip-version-check jinja2

```

build

```
[root@i-wsad3ybt RedisTimeSeries]# make build
Compiling chunk.c...
Compiling compressed_chunk.c...
Compiling config.c...
Compiling compaction.c...
Compiling generic_chunk.c...
Compiling gorilla.c...
Compiling indexer.c...
Compiling module.c...
Compiling parse_policies.c...
Compiling rdb.c...
Compiling tsdb.c...
Building rmutil...
parse_policies.c: In function ‘parse_string_to_millisecs’:
parse_policies.c:26:5: warning: format ‘%llu’ expects argument of type ‘long long unsigned int *’, but argument 3 has type ‘u_int64_t *’ [-Wformat=]
     if (sscanf(timeStr, "%llu%c%c", &timeSize, &interval_type, &should_be_empty) != 2) {
     ^
Compiling ../../deps/RedisModulesSDK/rmutil/util.c...
Compiling ../../deps/RedisModulesSDK/rmutil/strings.c...
Compiling ../../deps/RedisModulesSDK/rmutil/sds.c...
Compiling ../../deps/RedisModulesSDK/rmutil/alloc.c...
Compiling ../../deps/RedisModulesSDK/rmutil/vector.c...
Compiling ../../deps/RedisModulesSDK/rmutil/periodic.c...
Creating ../../bin/linux-x64-release/rmutil/librmutil.a...

```

生成 /Timeserials/bin/TimeSerials.so 文件，需要加载到Redis server。ls 

#### 4.4  Redis加载模块TimeSerials

##### 4.4.1 通过普通方式加载

模块有两种加载方式，一是在配置文件redis.conf中使用
 `loadmodule /path/to/TimeSerials.so` 在 Redis 启动时加载。

查看加载的模块:

![img](https:////upload-images.jianshu.io/upload_images/1812901-6174b95e79afa596?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

file

另一种方式在运行时使用命令 `MODULE LOAD /path/to/panda.so` 加载。

![img](https:////upload-images.jianshu.io/upload_images/1812901-68fde2070ee97b98?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

file

使用MODULE UNLOAD panda卸载。

![img](https:////upload-images.jianshu.io/upload_images/1812901-93b98a732e808423?imageMogr2/auto-orient/strip|imageView2/2/w/926/format/webp)

file

在载入的模块的时候可以传入参数，如：loadmodule panda.so hello panda 1234，
 参数会被传入模块的OnLoad方法中。



##### 4.4.2通过Docker 加载

You can either get RedisTimeSeries setup in a Docker container or on your own machine.

To quickly try out RedisTimeSeries, launch an instance using docker:

```
docker run -p 6379:6379 -it --rm redislabs/redistimeseries

```



进入容器内部访问命令：

```
[root@i-s21hd6yt ~]# docker  exec -it c0c2613ab7dd  /bin/bash
root@c0c2613ab7dd:/data# redis-cli
127.0.0.1:6379> ls
(error) ERR unknown command `ls`, with args beginning with: 
127.0.0.1:6379> MODULES
(error) ERR unknown command `MODULES`, with args beginning with: 
127.0.0.1:6379> modules
(error) ERR unknown command `modules`, with args beginning with: 
127.0.0.1:6379> MODULE LIST
1) 1) "name"
   2) "timeseries"
   3) "ver"
   4) (integer) 10207
127.0.0.1:6379> 

```



##### 4.4.3 代码访问TimeSerials

```
 RedisTimeSeries rts = new RedisTimeSeries("localhost", 6379);
   
   Map<String, String> labels = new HashMap<>();
   labels.put("country", "US");
   labels.put("cores", "8"); 
   rts.create("cpu1", 60*10 /*10min*/, 100, labels);
   
   rts.create("cpu1-avg", 60*10 /*10min*/, 100, null);
   rts.createRule("cpu1", Aggregation.AVG, 60 /*1min*/, "cpu1-avg");
   
   rts.add("cpu1", System.currentTimeMillis()/1000 /* time sec */, 80);
   
   // Get all the timeseries in US in the last 10min average per min  
   rts.mrange(System.currentTimeMillis()/1000 - 10*60, System.currentTimeMillis()/1000, Aggregation.AVG, 60, "country=US")
```







#### 6.基于Docker 安装 reids

You can either get RedisTimeSeries setup in a Docker container or on your own machine.

To quickly try out RedisTimeSeries, launch an instance using docker:

```
sudo docker run -p 6379:6379 --name=redis --restart=always  redislabs/redistimeseries

如果不在服务器上：
redis-server --loadmodule /home/RedisTimeSeries/bin/redistimeseries.so
```



```
创建容器时没有添加参数  --restart=always ，导致的后果是：当 Docker 重启时，容器未能自动启动。

现在要添加该参数怎么办呢，方法有二：

1、Docker 命令修改

docker container update --restart=always 容器名字
```



## 附录3：配置库Git使用

https://www.jianshu.com/p/25e5e07b2464  如果看不到图片，请参考

### 1 GitHub工作流程与介绍

github是通过Git进行版本控制的软件源代码托管服务平台。github除了Git代码仓库托管及基本的Web管理界面以外，它还提供了一些方便社会化共同软件开发的功能，即一般人口中的社群功能，包括允许用户追踪其他用户、组织、软件库的动态，对[软件代码](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=4196027&ss_c=ssc.citiao.link)的改动和bug提出评论等。

#### 1.1 工作流程

![image-20200223111840767](./img/image-20200223111840767.png)

上图展示了git的整体架构，以及和各部分相关的主要命令，其中涉及的各部分。

1. ***工作区(working directory)，***简言之就是你工作的区域。对于git而言，就是本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。

   git add 【文件名】或者【 . (全部)】：将文件从工作去提交到暂存区

   git pull：将远程仓库的改动更新到本地工作区

2. ***暂存区(stage area, 又称为索引区index)，***是git中一个非常重要的概念。是我们把修改提交版本库前的一个过渡阶段。查看GIT自带帮助手册的时候，通常以index来表示暂存区。在工作目录下有一个.git的目录，里面有个index文件，存储着关于暂存区的内容。git add命令将工作区内容添加到暂存区。

   git commit -m "提交描述"：将暂存区提交到本地仓库

3. ***本地仓库(local repository)，***版本控制系统的仓库，存在于本地。当执行git commit命令后，会将暂存区内容提交到仓库之中。在工作区下面有.git的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。这里也可以使用merge或rebase将***远程仓库副本***合并到本地仓库。图中的只有merge，注意这里也可以使用rebase。

   git push：将本地仓库提交到远程仓库

4. ***远程库(remote repository)***与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过push/pull可实现本地与远程的交互；

   git pull：将远程仓库的改动更新到本地工作区

   

   其他命令：

   git remote -v：查看origin和upstream源

   git remote add origin/upstream git地址：添加origin/upstream源

   git fetch upstream：获取upstream源仓库的提交和改变

   git checkout master：切换到master

   git merge upstream/master：合并远程的master

#### 1.2 栏目介绍

![image-20200222194828116](./img/image-20200222194828116.png)

- code：代码所在地
- issues：讨论、bug跟踪
- pull request：提交请求，进行code view
- project：项目管理、工作计划
  1. To Do：待完成任务
  2. Doing：正在进行中
  3. Done：已完成的
- Wiki：项目介绍，资料存放处（可放md格式）





### 2. Git安装与配置

####  2.1  准备工作

1. Git官网（https://git-scm.com/）下载Git。
2. GitHub官网（https://github.com/）注册账号。
3. 测试仓库 https://github.com/liuxinfengabc/cultivate.git 

#### 2.2 安装Git

1. 点击安装，选择目录为根目录，文件夹为Git，然后Next->默认安装。
2. 安装完成后打开根目录，找到Git文件夹，右键git-bash.exe可执行文件将其固定的工具栏，点击git-bash.exe运行。
3. 输入指令 ls 查看文件目录。

![image-20200222201309260](./img/image-20200222201309260.png)

**正常安装完成！**

#### 2.3 运行Git注册用户

1. 设置用户名和邮箱。

   设置用户名：$ git config --global user.name "Your Name"。

   设置邮箱：  $ git config --globaluser,email "email@example.com"。

   设置用户名和邮箱，修改后提交到远程仓库能够看到是提交者，用于在团队合作开发中，表明代码作者。

   ```
   1. 查看当前登录账号：
   git config user.name
   2. 查看当前登录邮箱：
   git config user.email
   3. 修改用户名和邮箱：
   git config --global user.name "liuxinfeng"
   git config --global user.email "624310862@qq.com"
   ```

   

2. 输入 $ git init 启动Git。

#### 2.4 GitHub设置公钥免密提交

1. .新建/连接主存储库。

2. 输入 $ ssh-keygen -t rsa -C "[email@example.com](mailto:"13963639551@163.com")" 按三次回车生成公钥，在C:\Users\Administrator\.ssh下找到id_rsa.pub文件，记事本打开复制公钥。或则

   ```
   例如：  ssh-keygen -t rsa -C "624310862@qq.com"
   ```

   ![image-20201004110748530](img/image-20201004110748530.png)

   

   

   ![image-20200317164409192](./img/image-20200317164409192.png)

3. 在GitHub上新建密钥，自定义标题（title）将公钥粘贴保存。

   1. 选择设置

      ![image-20200317182418527](./img/image-20200317182418527.png)

   2. 知道到SSH and GPS keys 菜单，点击 New SSH key

   

   ![image-20200317170729077](./img/image-20200317170729077.png)

   3. 复制生成的key![image-20200317170812465](./img/image-20200317170812465.png)
   4. 收到邮件

   ![image-20200317170928135](./img/image-20200317170928135.png)



#### 2.5 常用git命令

1. 文件操作

   - mkdir 文件名：创建文件夹
   - cd 文件夹名：进入文件夹
   - touch 文件名：创建文件
   - git rm 文件名

2. 复制仓库

   - git init：在本地初始化，创建Git仓库
   - git clone：  复制仓库到本地仓库。
   - git status：查看当前状态

3. 提交信息

   - git add 【文件名】或者【 . (全部)】：将文件从工作去提交到暂存区

   - git commit -m "提交描述"：将暂存区提交到本地仓库

   - git push：将本地仓库提交到远程仓库

     ```
     在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了
      git push的一般形式为 git push <远程主机名> <本地分支名> <远程分支名> ，
      
      例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。
     
     git push origin master
     如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建
     git push origin ：refs/for/master
     如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master
     git push origin
     如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支
     git push
     如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名
     ```

     

4. 更新仓库信息

   - git pull：将远程仓库的改动更新到本地工作区
   - git remote -v：查看origin和upstream源
   - git remote add origin/upstream git地址：添加origin/upstream源
   - git fetch upstream：获取upstream源仓库的提交和改变
   - git checkout master：切换到master
   - git merge upstream/master：合并远程的master



### 3. Git基本操作



此处开发人员自己根据指令创建仓库 ，仓库名为helloworld-姓名拼音

#### 3.1GitHub创建远程仓库

1. 创建主程序仓库helloworld，账户liuxinfengabc,属性为public

![image-20200317182619515](./img/image-20200317182619515.png)

2. 仓库名字helloworld,属性public，任何人可见，初始化一个readme文件。

   ![image-20200317183038029](./img/image-20200317183038029.png)

3. 创建成功 https://github.com/liuxinfengabc/helloworld

   ![image-20200317184000460](./img/image-20200317184000460.png)



#### 3.2 GitHub中提交文件

​    在github中可以进行简单操作，创建文件，提交文件，如何复杂的操作，需要在本地仓库进行操作，提交。



![image-20200317191347282](./img/image-20200317191347282.png)



#### 3.3 创建本地库，从GitHub更新内容与提交

　　**git init**  主要用来初始化一个空的`git`本地仓库。执行完上面的命令，当前目录下会自动生成`.git`隐藏文件夹，该隐藏文件夹就是`git`版本库。

​	   使用方法：进入某个空的文件夹下，打开`Git Bash`命令窗口输入以下命令，下载文件

1. git init  

2. git clone https://github.com/github-develop/helloworld.git

   

![image-20200402102435432](./img/image-20200402102435432.png)

3. 下载结果

   ![image-20200402103110234](./img/image-20200402103110234.png)

#### 

### 4. 高级操作



####  4.0主程序员仓库，开发人员仓库。

​	1. 本文假定：主程序员GitHub地址：https://github.com/liuxinfengabc/helloworld

​	2.  开发人员登录，先从主程序员GitHub（https://github.com/liuxinfengabc/helloworld）中点击fork，将文件复制到自己的Github中：

​	开发人员GitHub地址：https://github.com/github-develop/helloworld

3. 获取项目地址

   https://github.com/github-develop/helloworld.git

   ![image-20200402100120361](./img/image-20200402100120361.png)



#### 4.1 GitHub创建主程序仓库

1. 创建主程序仓库helloworld，账户liuxinfengabc,属性为public

![image-20200317182619515](./img/image-20200317182619515.png)

2. 仓库名字helloworld,属性public，任何人可见，初始化一个readme文件。

   ![image-20200317183038029](./img/image-20200317183038029.png)

3. 创建成功 https://github.com/liuxinfengabc/helloworld

   ![image-20200317184000460](./img/image-20200317184000460.png)

#### 4.2  GitHub 创建开发者仓库

1. 创建开发人员账号  

![image-20200317184258156](./img/image-20200317184258156.png)

2. 创建开发账户 ，申请新的QQ邮箱 1871418434@qq.com进行账户的创建。

3. 登录Github进行邮箱验证

4. 前往 https://github.com/liuxinfengabc/helloworld，点击Fork，复制代码到自己的开发者仓库

   ![image-20200317185838626](./img/image-20200317185838626.png)

5. Fork成功

   ![image-20200317190840670](./img/image-20200317190840670.png)

6. 回到自己的界面github.com,看到自己Fork的代码

![image-20200317191034972](./img/image-20200317191034972.png)



#### 



#### 4.3 创建本地库，从GitHub更新内容与提交

　　**git init**  主要用来初始化一个空的`git`本地仓库。执行完上面的命令，当前目录下会自动生成`.git`隐藏文件夹，该隐藏文件夹就是`git`版本库。

​	   使用方法：进入某个空的文件夹下，打开`Git Bash`命令窗口输入

1. git init  

2. git clone https://github.com/github-develop/helloworld.git

![image-20200402102435432](./img/image-20200402102435432.png)

3. 下载结果

   ![image-20200402103110234](./img/image-20200402103110234.png)

#### 4.4  向远程仓库添加文件

开发者在本地修改内容后，需要进入要操作的文件夹内进行git操作

1. git add .  # .   表示当前文件夹
2. git commit -m "注释信息“
3. git push  #推送到开发者仓库

##### 3.2.1 开发者工作区-->开发者远程仓库

  命令操作，打开 git bash 命令：

- cd test   #进入文件夹
- touch one.js   
- git add one.js  #添加需要提交的文件
- git status  #查看状态
- git commit    -m "修改XXXXXX"  #提交到本地仓库
- git push  #从本地仓库推送到远程仓库

**这时候只是在自己的GitHub仓库，还没有到主程序员的GitHub仓库**

**解决git push代码到github上一直提示输入用户名及密码的问题**

在github系统上克隆代码的地址默认采用的是http的方式，我们一般这样clone代码：
git clone https://github.com/yychuyu/linux-system-programming.git
而如果采用ssh方式的话，是这样clone代码的：
git clone git@github.com:yychuyu/linux-system-programming.git

解决办法很简单，将http方式改为ssh方式即可。

1 先查看当前方式：
git remote -v

2 把http方式改为ssh方式。先移除旧的http的origin：
git remote rm origin

3 再添加新的ssh方式的origin：
git remote add origin git@github.com:yychuyu/linux-system-programming.git

4 检查一下有没改变成功：
git remote -v

5 改动完之后直接执行git push是无法推送代码的，需要设置一下上游要跟踪的分支，与此同时会自动执行一次git push命令，此时已经不用要求输入用户名及密码啦！
git push --set-upstream origin master

##### 3.2.2 开发者GitHub仓库-->主程序员GitHub仓库

1. 登录Github,进入项目，点击New pull request 命令，

   ![image-20200402104035230](./img/image-20200402104035230.png)

2. 通过Create pull request 进行提交，**提交给主程序员了，通知审核**

![image-20200402104419033](./img/image-20200402104419033.png)



![image-20200402104556523](./img/image-20200402104556523.png)

```
[
github-develop](https://github.com/github-develop) wants to merge 1 commit into [liuxinfengabc:master](https://github.com/liuxinfengabc/helloworld) from [github-develop:master](https://github.com/github-develop/helloworld)
```



![image-20200402104616149](./img/image-20200402104616149.png)

##### 3.2.3主程序员合并request

1. 主程序员登录Github ，查看pull request 

   ![image-20200402105008810](./img/image-20200402105008810.png)

2. 点击FileChanged 查看修改内容，进行审核，并进行合并

![image-20200222222059393](./img/image-20200222222059393.png)



**这样就从开发人员的GitHub中更新到自己原来fork的仓库主程序员中了**

#### 3.3 同步主程序员仓库中的更新

**说明：开发人员仓库和主程序员的仓库是两个独立的仓库，主程序员仓库更新后不会自动更新到开发人员仓库中**。需要主动进行更新。

可以通过GitHub界面直接操作，参见:

```
https://blog.csdn.net/qq1332479771/article/details/56087333?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase
```

也可以参见命令行：

##### 3.3.1 基本步骤

1. git remote -v：查看origin和upstream源

2. git remote add origin/upstream git地址：添加origin/upstream源

   git remote add origin/upstream  git@github.com:liuxinfengabc/cultivate.git

3. git remote rm origin/upstream  #删除origin/upstream

4. git fetch upstream

5. git checkout master

6. git merge upstream/master

7. git push

##### 3.3.2 开发人员的仓库

可以看出这时候开发人员的仓库还没更新。

1. git remote -v：查看origin和upstream源。

   - origin 表示远程主机（开发人员仓库），upstream表示（主程序员仓库）

   - liuxinfengabc账户登录（主程序员账户）

     ```
     D:\idea-work\zup-boot-org>git remote -v
     origin  https://github.com/zonedaylab/zup-boot.git (fetch)
     origin  https://github.com/zonedaylab/zup-boot.git (push)
     ```

     

2. 添加主程序仓库地址

   git remote add upstream https://github.com/liuxinfengabc/helloworld

3. git fetch upstream  # 获取远程主程序仓库（upstream)代码

4. git checkout master   #切换到本地Master

5. git merge upstream/master  #合并远程分支  

6. git push  #推送到开发人员远程仓库。

   **此时，开发人员本地库已经和主程序员的原仓库已经完全同步了。但是注意，此时只是你电脑上的本地库和远程的github原仓库同步了，你自己的github仓库还没有同步，此时需要使用“git push”命令把你本地的仓库提交到github中。**

![image-20200222225834676](./img/image-20200222225834676.png)

![image-20200222224752723](./img/image-20200222224752723.png)



#### 3.4 版本回退

**说明：如果发现某次的版本提交完毕后有错误，需要回退，可以用下面的方法**

==步骤：==

1. git log  #查看版本

2. git reset --hard 版本号   #回退版本（本地）

3. git push -f   #push到远程仓库

   

![image-20200222231335512](./img/image-20200222231335512.png)

![image-20200222231719188](./img/image-20200222231719188.png)

![image-20200222231733144](./img/image-20200222231733144.png)

![image-20200222232302058](./img/image-20200222232302058.png)

![image-20200222232320868](./img/image-20200222232320868.png)

**此时回退版本已经完毕**



**==当push出错时可以尝试下面的命令==**

- git push origin master
- git push -f origin master

#### 3.5 常见错误



#### 3.5.1解决GitHub每次push时都提示输入用户名和密码的问题

1. 原因

   我们在建立远程仓库或者克隆项目时，使用的是HTTPS方式 ，HTTPS方式push不会保存用户名和密码。我们需要把HTTPS方式改成SSH的方式

2. 查看远程连接方式 git remote -v

```
$ git remote -v
origin  git@github.com:liuxinfengabc/https://github.com/liuxinfengabc/cultivate/cultivate.git (fetch)
origin  git@github.com:liuxinfengabc/https://github.com/liuxinfengabc/cultivate/cultivate.git (push)
```

3. 删除origin

```
$ git remote rm origin
```

4.配置SSH方式

![image-20200421113034366](./img/image-20200421113034366.png)

```
$ git remote add origin git@github.com:liuxinfengabc/cultivate.git
```

### 4. 开发环境中使用GitHub

#### 4.1 tortoiseGit(windows)简化操作

tortoiseGit是一个开放的git版本控制系统的源客户端，支持Winxp/vista/win7.该软件功能和git一样,不同的是：git是命令行操作模式，tortoiseGit界面化操作模式，不用记git相关命令就可以直接操作，可根据自己情况选择安装.

tortoiseGit下载地址：https://download.tortoisegit.org/tgit/

1. git commit 操作。 修改了文件后，右键选择commit，输入Message后，点Commit提交到本地仓库。

![img](./img/wps3.png) 

2. git pull 拉取服务器文件。在项目文件夹下右键菜单，选择TortoiseGit->Pull，点击OK.
3. git push 提交代表到服务器，TortoiseGit-> git push

![img](./img/wps4.png) 

如果文件出现感叹号则表示有冲突，必须先解决冲突：

```
1.在点击close后可以直接在弹出的窗口中点击yes来查看冲突，也可以通过点击Diff看本地仓库文件和服务器上面的文件哪里冲突了。
2.在弹出的窗口中双击打开冲突文件，解决冲突问题。
3.冲突解决完之后，删除在目录下生成出的多余文件，再次commit。
```



新增篇：

第一步：在仓库中新增文件后，先pull，然后可以在diff中查看和仓库区别

第二步：右键->commit，选择你需要提交的文件，然后点击commit

第三步：push文件



#### 4.2 idea中使用Git/GitHub

##### 4.2.1 配置Git和GitHub

1. 设置git.exe路径

File-->Settings-->Version Control-->Git/GitHub

![image-20200222235204939](./img/image-20200222235204939.png)

2. 登录Github账户（添加账户）

![image-20200222235239154](./img/image-20200222235239154.png)



##### 4.2.2 从GitHub上clone项

1. File ->New->Project from Version Control

![image-20200222234926629](./img/image-20200222234926629.png)

2. 设置GitHub地址以及存储路径

![image-20200222235447325](./img/image-20200222235447325.png)

3. 点击Clone

![image-20200222235614107](./img/image-20200222235614107.png)

**4. 克隆完毕**



##### 4.2.3 提交项目到本地仓库/远程仓库

1. 添加新增文件(git add)

![image-20200223000755898](./img/image-20200223000755898.png)

2. 提交文件按 VCS-->Git-->Commit Changes

![image-20200223000919666](./img/image-20200223000919666.png)

![image-20200223001043046](./img/image-20200223001043046.png)

![image-20200223001108163](./img/image-20200223001108163.png)

![image-20200223001158304](./img/image-20200223001158304.png)

![image-20200223001227742](./img/image-20200223001227742.png)

**看到这个说明已经push成功**

![image-20200223001340225](./img/image-20200223001340225.png)

**如果往主程序员的仓库更新，就参考前面讲的pull request**

##### 4.2.4 更新项目到本地仓库

**若别人更新了仓库，在idea中怎么办呢？**

![image-20200223001756484](./img/image-20200223001756484.png)

![image-20200223001855840](./img/image-20200223001855840.png)

**这三个地方都可以**

![](./img/image-20200223001948419.png)

##### 4.2.5 在终端中使用Git命令

**File-->Settings-->Tools-->Terminal-->Shell path**

![image-20200223002248860](./img/image-20200223002248860.png)

Alt +F12 打开命令窗口，进行命令操作,与在Git bash下使用一样的效果，可以执行以下命令。

1. git remote -v：查看origin和upstream源

   ![image-20200402110905149](./img/image-20200402110905149.png)

2. git remote add origin/upstream git地址：添加origin/upstream源

3. git fetch upstream

4. git checkout master

5. git merge upstream/master

6. git push

   

##### 4.2.6 创建项目并上传github

![image-20200222234240245](./img/image-20200222234240245.png)

![image-20200222234341314](./img/image-20200222234341314.png)

**点击Share**

![image-20200222234527903](./img/image-20200222234527903.png)

**点击Add，就可以将项目传到GitHub上了，不存在仓库就会创建一个名字为testJava的仓库**

![image-20200222234621484](./img/image-20200222234621484.png)

**看到Successfully，表示创建成功**

![image-20200222234750674](./img/image-20200222234750674.png)

#### 4.3 eclipse中使用Git/Github

##### 4.3.1 eclipse中使用Git导入工程

1. 打开Git Repositories窗口，点击右上角Add an existing local Git Repository to this view图标
2. 在Directory中选择你本地Git总仓库，在下方选择你想导入的Git仓库目录
3. 打开你导入的仓库->Working Tree，选择你想导入的工程，右键->Import Projects...
4. 调整选项，导入工程
5. 右键已导入工程->Gradle->Refresh Gradle Project

##### 4.3.2 eclipse中使用Git同步工程

1. 右键工程->Team->Synchronize Workspace进入同步窗口
2. 对双向红箭头文件，打开，进行代码合并操作，操作完成后 右键->Mark asMerged
3. 选择要上传的文件，右键->Add to Index/在Unstaged Changes中右键->Add to Index
4. 在Staged Changes中可以查看要提交的文件，在Commit Message中输入提交内容备注，以及作者相关，点击commit至本地
5. Pull拉取服务器上更新文件
6. 最后Push至服务器

### 5.Gitlab使用

#### 5.1 idea使用Gitlab

##### 5.1.1下载Gitlab插件

![image-20200414095107062](./img/image-20200414095107062.png)

##### 5.1.2登录Github查找token

https下不用配置

![image-20200414101245181](./img/image-20200414101245181.png)



##### 5.1.3idea设置gitlab

![image-20200414101422198](./img/image-20200414101422198.png)

##### 5.1.4复制代码地址

![image-20200414101740614](./img/image-20200414101740614.png)

http://124.130.192.24:10015/liuxinfengabc/test.git

##### 5.1.5Clone代码

![image-20200414101845959](./img/image-20200414101845959.png)

5.1.6 更新代码

![image-20200414103447285](./img/image-20200414103447285.png)



出错：

![image-20200414103515381](./img/image-20200414103515381.png)



但是命令行可以：

![image-20200414103552308](./img/image-20200414103552308.png)

#### 5.2 pycharm使用Gitlab

与idea基本相同

##### 5.2.1下载gitlab插件

![image-20200417102133554](./img/image-20200417102133554.png)





##### 5.2.2配置GitLab服务器

![image-20200417102516613](./img/image-20200417102516613.png)



##### 5.2.3 Clone代码源

1. 获取代码地址，首先需要注册账户，并且有代码权限![image-20200417102824947](./img/image-20200417102824947.png)



```
http://git.iesnengyuan.com/jianda/gisofflinemapsystem
```

2. pyCharm执行Clone命令

```
打开VCS菜单-->Git--->Git Clone
```

![image-20200417103015025](./img/image-20200417103015025.png)

3. 输入用户名和密码

   ![image-20200417103115853](./img/image-20200417103115853.png)

##### 5.2.4配置Terminal 执行git命令

![image-20200417101821839](./img/image-20200417101821839.png)

ALT＋Ｆ１２显示终端

![image-20200417102022683](./img/image-20200417102022683.png)

#### 5.3 HBuilderX使用GitLab

##### 5.2.1git插件安装

1、打开工具--》插件安装

![image-20200417112726651](./img/image-20200417112726651.png)

2、安装git

![image-20200417114228788](./img/image-20200417114228788.png)



##### 5.2.2从gitlab加载项目

1、选择文件--》新建--》项目

![image-20200417114822339](./img/image-20200417114822339.png)



2、选择文件--》导入--》导入git项目--》输入地址--》导入即可

![image-20200417115247082](img/image-20200417115247082.png)

## 附录4:UML建模工具安装






```
 
1、你还在没经过设计就直接敲代码吗？ 设计先行的理念哪去了？
2、你难道不想要有一种工具，可以把你设计的东西直接转换成代码或者sql语句，以减轻你的工作量吗？
3、你想一直都敲代码吗？程序员可不是吃青春饭的，时间久了，就该要好好考虑转变开发角色的事情了。



一、什么是EA？
Enterprise Architect 是Sparx Systems 公司的旗舰产品。它覆盖了系统开发的整个周期，除了开发类模型之外，还包括事务进程分析，使用案例需求，动态模型，组件和布局，系统管理，非功能需求，用户界面设计，测试和维护等。    
```



详细讲解了EA的安装，用EA进行逆向工程，用EA画图，代码生成，EA合并文档，数据库设计等多个主题。

任务：

1. 完成EA的下载安装;
2. 使用EA画出类图;
3. 能够设计数据表，导出到物理数据库(mysql)
4. 提交格式：  姓名-班级-EA工具初步使用.doc

#### 1. 安装EA

1. 解压安装包。

2. 找到enterprisearchitect14\EA 14.0.1422下的easetup.msi。

   ![image-20200415164436594](img/image-20200415164436594.png)

   没有什么可注意的，直接默认就行，安装位置可以自己选。

   

3. 将patch下的EA.exe替换到你的EA安装目录下EA.exe。

4. 这就算破解完成了，接下来就可以正常使用了。

#### 2. 创建项目，创建Model

![image-20200415165444348](img/image-20200415165444348.png)



![image-20200415165602792](img/image-20200415165602792.png)

==下面添加Model，添加完Model，才能画Diagrams==

![image-20200415165718938](img/image-20200415165718938.png)

==选择你要创建哪种类型的图，然后点Create Pattern，这里我以创建类图进行举例==

![image-20200415170008917](img/image-20200415170008917.png)

创建完成

![image-20200415171043710](img/image-20200415171043710.png)



#### 3. 类图及自动生成

==这里我以画类图来举例==

创建一个类图Model

![image-20200420105013388](img/image-20200420105013388.png)

##### 3.1 创建类

1. 从Toolbox工具栏中选中class类拖到工作区

   ![image-20200420105249707](img/image-20200420105249707.png)

2. 设置类的变量

   - 在下面的Features栏中的Attribute设置变量

   ![image-20200420110148085](img/image-20200420110148085.png)

   

3. 设置类的方法

   - 在下面的Features栏中的Operations设置变量

   ![image-20200420110605170](img/image-20200420110605170.png)

##### 3.2 类关系连接

![image-20200420110923904](img/image-20200420110923904.png)



##### 3.3 EA从图自动生成代码

这里选择使用装饰模式画的图导出代码

![image-20200418131300571](img/image-20200418131300571.png)

![image-20200418131608629](img/image-20200418131608629.png)

==下面操作要Select All==

![image-20200418132334846](img/image-20200418132334846.png)

==看到下面这个就算导出成功了==

![image-20200418132429432](img/image-20200418132429432.png)

![image-20200418132452511](img/image-20200418132452511.png)

##### 3.4 EA代码逆向工程

##### 3.4.1创建一个project

![image-20200215154514618](img/image-20200215154514618.png)

##### 3.4.2右击model，添加一个Model用于工作视图

![image-20200215154615533](img/image-20200215154615533.png)

##### 3.4.3这里我选择一个简单的类图，点击Creat Pattern（s）

![image-20200215154729921](img/image-20200215154729921.png)

##### 3.4.4选择好咱们创建好的model

![image-20200215154839743](img/image-20200215154839743.png)

##### 3.4.5从上面栏中选择 code -> Import -> File -> Import Source Directory

或者选中model后直接使用快捷键 Crtl + Shift + u

![image-20200215155104633](img/image-20200215155104633.png)

##### 3.4.6选择好要导入文件的属性，点击OK

![image-20200215160045679](img/image-20200215160045679.png)

##### 3.4.7在左边就可以看到导入进来的包了

![image-20200215160202760](img/image-20200215160202760.png)

也可以查看图了

#### 4.EA合并两个eapx文档

**这是两个不同eapx文件中的Model**

![image-20200418132847482](img/image-20200418132847482.png)

![image-20200418132813472](img/image-20200418132813472.png)

下面咱们要将ProjectA和ProjectB两个文档合并到一起

==使用将一个ProjectB导出为xml，再在ProjectA中导入xml==

![image-20200418133143304](img/image-20200418133143304.png)

![image-20200418133257898](img/image-20200418133257898.png)

现在咱们切换到另一个工程里

![image-20200418133402894](img/image-20200418133402894.png)

![image-20200418133547361](img/image-20200418133547361.png)

==导入成功==

![image-20200418133631581](img/image-20200418133631581.png)

#### 5. EA进行数据库设计

##### 5.1选择模型

![image-20200418134611895](img/image-20200418134611895.png)

==这里我以创建Student数据库来做演示==

==这里一点需要注意的是选择Model时，要选择你要使用哪种类型的数据库，这儿呢我选择的是DB2，也可以选择其他的，比如MySql、SQlServer==

##### 5.2创建表格

![image-20200418171825857](img/image-20200418171825857.png)

![image-20200418201517356](img/image-20200418201517356.png)

选中数据库类型

![image-20200418201557928](img/image-20200418201557928.png)

![image-20200418201342104](img/image-20200418201342104.png)

==数据表建立完成==

![image-20200419113141961](img/image-20200419113141961.png)

##### 5.3设置外键

![image-20200419114333462](img/image-20200419114333462.png)

![image-20200419114415810](img/image-20200419114415810.png)

==外键设置完毕==

![image-20200419114518871](img/image-20200419114518871.png)

##### 5.4生成代码

![image-20200419114755771](img/image-20200419114755771.png)

![image-20200419114858279](img/image-20200419114858279.png)

==导出成功==

![image-20200419114924238](img/image-20200419114924238.png)

==导出内容==

```mysql
/* ---------------------------------------------------- */
/*  Generated by Enterprise Architect Version 14.0 		*/
/*  Created On : 19-4月-2020 11:48:59 				*/
/*  DBMS       : MySql 						*/
/* ---------------------------------------------------- */

SET FOREIGN_KEY_CHECKS=0
; 
/* Drop Tables */

DROP TABLE IF EXISTS `course` CASCADE
;

DROP TABLE IF EXISTS `sc` CASCADE
;

DROP TABLE IF EXISTS `student` CASCADE
;

/* Create Tables */

CREATE TABLE `course`
(
	`Cno` CHAR(4) NOT NULL,
	`Cname` CHAR(40) NULL,
	`Cpno` CHAR(4) NULL,
	`Ccredit` SMALLINT NULL,
	CONSTRAINT `PK_course` PRIMARY KEY (`Cno` ASC)
)

;

CREATE TABLE `sc`
(
	`Sno` CHAR(9) NOT NULL,
	`Cno` CHAR(4) NOT NULL,
	`Grade` SMALLINT NULL
)

;

CREATE TABLE `student`
(
	`Sno` CHAR(9) NOT NULL,
	`Sname` CHAR(20) NULL,
	`Ssex` CHAR(2) NULL,
	`Sage` SMALLINT NULL,
	`Sdept` CHAR(20) NULL,
	`Cno` CHAR(4) NULL,
	CONSTRAINT `PK_student` PRIMARY KEY (`Sno` ASC)
)

;

/* Create Foreign Key Constraints */

ALTER TABLE `sc` 
 ADD CONSTRAINT `FK_sc_course`
	FOREIGN KEY (`Cno`) REFERENCES `course` (`Cno`) ON DELETE Restrict ON UPDATE Restrict
;

ALTER TABLE `sc` 
 ADD CONSTRAINT `FK_sc_student`
	FOREIGN KEY (`Sno`) REFERENCES `student` (`Sno`) ON DELETE Restrict ON UPDATE Restrict
;

SET FOREIGN_KEY_CHECKS=1
; 

```

##### 5.5EA数据库反向工程

==目的：==

1. 不同数据库迁移。
2. 针对老系统的维护，系统中有几百张表，没有数据库设计文件，通过反向工程导入EA更好研究，再次进行设计。

由于EA不支持MySQL 64位的ODBC Driver，所以需要下载

==下载地址==

```
http://dev.mysql.com/get/Downloads/Connector-ODBC/5.1/mysql-connector-odbc-5.1.8-win32.msi/from/http://mysql.oss.eznetsols.org/ (windows 32bit)
```

安装的时候一直默认就行



控制面板--》管理工具--》ODBC Data Sources（32-bit）

![image-20200419161307057](img/image-20200419161307057.png)

![image-20200419161403489](img/image-20200419161403489.png)

![image-20200419161438870](img/image-20200419161438870.png)

![image-20200419161807217](img/image-20200419161807217.png)

==点击Test==

![image-20200419161820962](img/image-20200419161820962.png)

看到上面这个就可以点击OK了

==添加成功==

![image-20200419161858300](img/image-20200419161858300.png)

**接下来进行EA里面的操作**

![image-20200419162103495](img/image-20200419162103495.png)

![image-20200419162131140](img/image-20200419162131140.png)

![image-20200419162222916](img/image-20200419162222916.png)

![image-20200419162259288](img/image-20200419162259288.png)==

![image-20200419162330184](img/image-20200419162330184.png)

![image-20200419162432306](img/image-20200419162432306.png)

==导入成功==

![image-20200419162541311](img/image-20200419162541311.png)

如果想看外键之间的联系，将Database A图中的所有复制到Tables图中

![image-20200419162644882](img/image-20200419162644882.png)

![image-20200419162726922](img/image-20200419162726922.png)

#### 6 EA文件合并

1. 导出xml文件

![image-20200407161618506](./img/image-20200407161618506.png)

2. 导入xml文件

   ![image-20200407162124709](./img/image-20200407162124709.png)

3. 合并

   注意经过测试XML File也需要选择 和Merge相同的文件。

   ![image-20200407162238164](img/image-20200407162238164.png)
   
   ### 附录5：原型工具安装与使用
   
   
   
   